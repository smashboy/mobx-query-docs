---
title: Queries
description: Fetch and cache server data as reactive MobX entities using QueryMany, QueryOne, and Query Fragments.
---

Queries are how you fetch data from your server or database and receive it as **hydrated MobX entity instances**. Under the hood, mobx-query wraps TanStack Query — giving you all its caching, refetching, and deduplication benefits — while normalizing query results into your entity system.

mobx-query provides four query classes:

| Class               | Returns       | Suspense hook                   | Use case                                             |
| ------------------- | ------------- | ------------------------------- | ---------------------------------------------------- |
| `QueryMany`         | Entity array  | `useSuspenseQuery` / `useQuery` | Fetching a list of entities (e.g. all folders)       |
| `QueryOne`          | Single entity | `useSuspenseQuery`              | Fetching a single entity by ID                       |
| `QueryFragmentMany` | Entity array  | `useQuery`                      | Child/nested queries owned by a parent entity        |
| `QueryFragmentOne`  | Single entity | `useQuery`                      | Child/nested single-entity queries owned by a parent |

## QueryMany

Use `QueryMany` to define queries that return **a list of entities**. This is the most common query type — think "all folders", "recent documents", or "documents in folder X".

### Defining a QueryMany

```ts title="folders.store.ts"
import { QueryMany } from 'mobx-query/queries/QueryMany'
import { Folder } from './folder.entity'

export class FoldersStore {
  readonly foldersQuery = new QueryMany({
    entity: Folder,
    queryKey: () => ['folders'],
    queryFn: async (_, ctx) => {
      const res = await fetch('/api/folders')
      return res.json()
    },
  })
}
```

The options object has the following shape:

| Option      | Type                                             | Description                                                                |
| ----------- | ------------------------------------------------ | -------------------------------------------------------------------------- |
| `entity`    | Entity constructor                               | The entity class this query hydrates (e.g. `Folder`)                       |
| `queryKey`  | `() => unknown[]`                                | A function returning a static identifier array for this query              |
| `queryFn`   | `(args, context) => TData[] \| Promise<TData[]>` | The data-fetching function. Receives arguments and your registered context |
| `staleTime` | `number` (optional)                              | Time in ms before data is considered stale (passed to TanStack Query)      |
| `gcTime`    | `number` (optional)                              | Time in ms before inactive query data is garbage collected                 |

### Using in React

`QueryMany` exposes two hooks for React components:

#### `useSuspenseQuery(args)`

Suspends the component until data is available. Returns a **guaranteed non-empty** entity array (no loading states to handle):

```tsx
import { observer } from 'mobx-react-lite'
import { Suspense } from 'react'

const FolderList = observer(() => {
  const { rootStore } = useMQ()
  const folders = rootStore.folders.foldersQuery.useSuspenseQuery(undefined)

  return (
    <ul>
      {folders.map((folder) => (
        <li key={folder.id}>{folder.displayTitle}</li>
      ))}
    </ul>
  )
})

// Wrap with Suspense boundary
;<Suspense fallback={<Loading />}>
  <FolderList />
</Suspense>
```

#### `useQuery(args, enabled?)`

A non-suspense variant that returns entities immediately (empty array until loaded). Supports an `enabled` flag to conditionally skip the query:

```tsx
const FolderList = observer(() => {
  const { rootStore } = useMQ()
  const folders = rootStore.folders.foldersQuery.useQuery(undefined)

  // folders is [] while loading, then populated
  return (
    <ul>
      {folders.map((folder) => (
        <li key={folder.id}>{folder.displayTitle}</li>
      ))}
    </ul>
  )
})
```

### Query Arguments

The first type parameter of `QueryMany` defines the shape of the arguments passed to `queryFn` and hooks. Use this for parameterized queries:

```ts
readonly documentsByFolderQuery = new QueryMany({
  entity: Document,
  queryKey: () => ['documentsByFolder'],
  queryFn: async (folderId: string, ctx) => {
    return ctx.db.query.document.findMany({
      where: { folderId },
    });
  },
});

// Usage:
const docs = documentsByFolderQuery.useSuspenseQuery('folder-123');
```

If your query doesn't need arguments, use `undefined` as the argument type and pass `undefined` when calling hooks.

## QueryOne

Use `QueryOne` to fetch a **single entity** by its identifier or any unique criteria.

### Defining a QueryOne

```ts title="folders.store.ts"
import { QueryOne } from 'mobx-query/queries/QueryOne'
import { Folder } from './folder.entity'

export class FoldersStore {
  readonly folderByIdQuery = new QueryOne({
    entity: Folder,
    queryKey: () => ['folderById'],
    queryFn: async (folderId: string, ctx) => {
      const res = await fetch(`/api/folders/${folderId}`)
      return res.json()
    },
  })
}
```

### Using in React

`QueryOne` provides `useSuspenseQuery(args)` which returns a **single entity instance** (not an array):

```tsx
const FolderDetail = observer(({ folderId }: { folderId: string }) => {
  const { rootStore } = useMQ()
  const folder = rootStore.folders.folderByIdQuery.useSuspenseQuery(folderId)

  return (
    <div>
      <h1>{folder.displayTitle}</h1>
      <p>{folder.description}</p>
    </div>
  )
})
```

## How Query Keys Work Under the Hood

One of the key design decisions in mobx-query is how query keys are constructed. You provide a `queryKey` function that returns your logical identifier, but mobx-query **wraps it** with additional prefixes to enable entity-based cache management.

### Key Construction

Every query's full key is composed of three parts:

```
[ EntityName, QueryPrefix, ...yourQueryKey, args ]
```

For example, given this query definition:

```ts
const foldersQuery = new QueryMany({
  entity: Folder,
  queryKey: () => ['folders', 'recent'],
  queryFn: async (limit: number) => {
    /* ... */
  },
})
```

When called with `foldersQuery.useSuspenseQuery(5)`, the actual TanStack Query key becomes:

```ts
;['Folder', '__query__many__', 'folders', 'recent', 5]
```

| Segment               | Source                  | Purpose                                                              |
| --------------------- | ----------------------- | -------------------------------------------------------------------- |
| `'Folder'`            | Entity constructor name | Groups all queries for this entity type — used for bulk invalidation |
| `'__query__many__'`   | Internal query prefix   | Distinguishes between `QueryMany`, `QueryOne`, and fragment variants |
| `'folders', 'recent'` | Your `queryKey()`       | Your custom logical identifier                                       |
| `5`                   | `args`                  | The runtime arguments passed to the hook                             |

### Why This Matters

The entity name prefix enables powerful features:

1. **Bulk invalidation** — After a `CreateMutation` with `invalidationStrategy: 'all-queries'`, mobx-query can call `queryClient.invalidateQueries({ queryKey: ['Folder'] })` to invalidate _every_ query related to the `Folder` entity.

2. **Query hash tracking** — Each entity instance stores a set of `queryHashes` linking it to the TanStack Query cache entries that reference it. When a cache entry is garbage collected, mobx-query removes the hash from all entities and cleans up orphaned entities automatically.

3. **Hash-based invalidation** — The `invalidate(args)` method on queries uses `hashKey()` from TanStack Query to produce a deterministic hash, then directly invalidates that specific cache entry without needing to match by query key.

### What Gets Stored in the Cache

A crucial architecture detail: mobx-query does **not** store raw data in TanStack Query's cache. Instead, it stores **entity IDs** (or ID arrays):

```
TanStack Query cache entry:
  key: ['Folder', '__query__many__', 'folders']
  data: ['id-1', 'id-2', 'id-3']  // ← entity IDs, not raw data
```

When a hook reads from the cache, the ID array is resolved to live entity instances via the `EntityManager` collection. This is what enables normalized, deduplicated entity sharing across queries.

## Helper Methods

All query classes inherit useful methods from their base classes for working with the cache outside of React hooks.

### `prefetch(args)`

Pre-fetches data and populates the cache **before** a component renders. Useful for route loaders or hover prefetching:

```ts
// In a route loader
await foldersQuery.prefetch(undefined);

// On hover
onMouseEnter={() => folderByIdQuery.prefetch(folderId)}
```

### `ensureData(args)`

Similar to `prefetch`, but **returns the data** if it already exists in the cache. Only fetches if the cache is empty:

```ts
const entityIds = await foldersQuery.ensureData(undefined)
```

### `invalidate(args)`

Manually invalidates a specific query cache entry by its arguments. If the query is currently active (mounted in a component), it will immediately refetch:

```ts
// Invalidate a specific parameterized query
foldersQuery.invalidate(undefined)

// Invalidate a specific folder detail
folderByIdQuery.invalidate('folder-123')
```

<Callout type="info">
  Under the hood, `invalidate()` computes the query hash from the args and uses
  `invalidateQueryByHash()` to target the exact cache entry. If the query is
  active, it triggers an immediate refetch. If the query has been garbage
  collected, the invalidation is silently ignored.
</Callout>

### `setQueryData(data, args)`

Manually injects data into the query cache **without fetching**. The data is hydrated into entities through the normal `EntityManager` pipeline:

```ts
// Inject a list of folders into the cache
foldersQuery.setQueryData(serverFolders, undefined)

// Inject a single folder
folderByIdQuery.setQueryData(folderRecord, 'folder-123')
```

This is useful for:

- Hydrating the cache with data from a parent query (avoiding redundant fetches).
- Server-side rendering / initial data.
- Optimistic updates in custom mutation handlers.

### `getQueryIds(args)` (QueryMany only)

Returns the current array of entity IDs stored in the TanStack Query cache for a given set of arguments:

```ts
const ids = foldersQuery.getQueryIds(undefined)
// => ['id-1', 'id-2', 'id-3']
```

### `setQueryIds(ids, args)` (QueryMany only)

Directly sets the entity ID array in the cache. Used internally by relation mutations for optimistic updates:

```ts
foldersQuery.setQueryIds(['id-1', 'id-2', 'id-4'], undefined)
```

### `getQueryKey(args)` (QueryMany only)

Returns the full constructed query key for a given set of arguments. Useful when integrating with TanStack Query directly:

```ts
const queryKey = foldersQuery.getQueryKey(undefined)
// => ['Folder', '__query__many__', 'folders']
```

## Query Fragments

Query Fragments (`QueryFragmentMany` and `QueryFragmentOne`) are a specialized query variant designed for **child data owned by a parent entity**. Think of them as sub-queries that live on an entity instance rather than in a store.

### The Problem They Solve

Consider a `Document` entity that has many `Label` entities. You could define a global labels-for-document query in a store, but there's a conceptual issue: the labels _belong_ to a specific document. They're not a top-level collection — they're a **fragment** of a parent entity's data.

Furthermore, when a parent query already includes the nested data (e.g. a document query that joins labels), you want to hydrate those labels into the entity directly from the parent's response — without triggering an independent fetch.

### How Fragments Differ from Regular Queries

| Behavior                | `QueryMany` / `QueryOne`             | `QueryFragmentMany` / `QueryFragmentOne`                           |
| ----------------------- | ------------------------------------ | ------------------------------------------------------------------ |
| **Cache lifetime**      | Controlled by `staleTime` / `gcTime` | Infinite `staleTime` and `gcTime` — cache never expires on its own |
| **React hooks**         | `useSuspenseQuery` + `useQuery`      | `useQuery` only (no suspense)                                      |
| **Typical location**    | Declared in a store                  | Declared on an entity instance                                     |
| **Primary data source** | Independent fetch                    | Hydrated from parent query via `setQueryData`, with fallback fetch |

The key difference is that fragments have `staleTime: Infinity` and `gcTime: Infinity`. This means once data is seeded (usually by the parent entity's `hydrate()`), the fragment query won't refetch on its own. The parent entity controls the lifecycle.

### Defining a Query Fragment

Fragments are typically declared as `readonly` properties on an entity:

```ts title="document.entity.ts"
import { Entity } from 'mobx-query/entity/Entity'
import { QueryFragmentMany } from 'mobx-query/queries/QueryFragmentMany'
import { Label } from './label.entity'

export class Document extends Entity<string, DocumentData> {
  id: string = crypto.randomUUID()
  @observable accessor title: string = ''

  // Fragment: labels belonging to this document
  readonly labelsQuery = new QueryFragmentMany({
    entity: Label,
    queryKey: () => ['documentLabels', this.id],
    queryFn: (_, { db }) => {
      return db.query.label.findMany({
        where: { documentId: this.id },
      })
    },
  })

  hydrate(data: DocumentData) {
    this.id = data.id
    this.title = data.title

    // Seed the fragment from the parent query's joined data
    if (data.labels) {
      this.labelsQuery.setQueryData(data.labels, undefined)
    }
  }
}
```

### The Fragment Pattern in Practice

Here's the typical flow:

1. A parent query fetches documents **with their labels joined**:

   ```ts
   const documentsQuery = new QueryMany({
     entity: Document,
     queryKey: () => ['documents'],
     queryFn: (_, { db }) =>
       db.query.document.findMany({
         with: { labels: true }, // include labels in the response
       }),
   })
   ```

2. When each `Document` is hydrated, its `hydrate()` method calls `this.labelsQuery.setQueryData(data.labels)` — seeding the fragment cache from the parent response.

3. When a component renders the labels:

   ```tsx
   const DocumentLabels = observer(({ document }: { document: Document }) => {
     const labels = document.labelsQuery.useQuery(undefined)

     return (
       <div>
         {labels.map((label) => (
           <Badge key={label.id}>{label.displayTitle}</Badge>
         ))}
       </div>
     )
   })
   ```

   Since the fragment's cache was already seeded by `hydrate()` and has `staleTime: Infinity`, **no additional network request** is made. The labels are immediately available.

4. If the parent query didn't include labels (or the fragment is accessed independently), the fragment's `queryFn` runs as a fallback, fetching the data on demand.

### When to Use Fragments vs Regular Queries

Use **Query Fragments** when:

- The data is a **child/dependant** of a specific entity (one-to-many or one-to-one relationships).
- The parent query can pre-populate the data via joins (avoiding waterfalls).
- You want the fragment's cache lifecycle to be controlled by its parent.
- You don't need Suspense support for this data.

Use **Regular Queries** (`QueryMany` / `QueryOne`) when:

- The data is a **top-level collection** (e.g. "all folders", "user settings").
- You want TanStack Query's standard stale/gc behavior to manage refetching.
- You need Suspense support.
- The query is defined in a store, not on an entity.

<Callout type="idea">
  A useful mental model: **Queries** are for data you fetch from the "outside"
  (stores), while **Fragments** are for data that is a natural part of an
  entity's shape but loaded separately or nested within a parent response.
</Callout>

## Queries Defined on Entities vs Stores

You can define queries in two places:

### In a Store (top-level queries)

```ts
export class FoldersStore {
  readonly foldersQuery = new QueryMany({
    entity: Folder,
    queryKey: () => ['folders'],
    queryFn: async (_, ctx) => {
      /* ... */
    },
  })
}
```

This is the right place for **collections** — queries that aren't scoped to a specific entity instance.

### On an Entity (instance-scoped queries)

```ts
export class Folder extends Entity<string, FolderData> {
  readonly documentsQuery = new QueryMany({
    entity: Document,
    queryKey: () => ['folderDocuments', this.id],
    queryFn: (_, ctx) =>
      ctx.db.query.document.findMany({
        where: { folderId: this.id },
      }),
  })
}
```

When a query is defined on an entity, it uses `this.id` in its `queryKey`. This means each `Folder` instance gets its own distinct, parameterized query — `['folderDocuments', 'folder-1']`, `['folderDocuments', 'folder-2']`, etc. The query is co-located with the data it relates to, keeping your code organized and discoverable.
