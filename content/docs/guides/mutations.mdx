---
title: Mutations
description: Create, update, and delete entities with built-in optimistic updates and configurable rollback strategies.
---

Mutations in mobx-query handle **write operations** — creating new entities, updating existing ones, and deleting records. Every mutation class integrates with TanStack Query's mutation cache and provides built-in optimistic update behavior with configurable strategies.

mobx-query provides three mutation classes:

| Class            | Purpose                            | Defined on      |
| ---------------- | ---------------------------------- | --------------- |
| `CreateMutation` | Insert a new entity                | Store           |
| `UpdateMutation` | Modify an existing entity's fields | Entity instance |
| `DeleteMutation` | Remove an entity                   | Entity instance |

## CreateMutation

`CreateMutation` handles the creation of new entities. It provides **instant optimistic insertion** — the entity appears in the UI immediately without waiting for the server response.

### How It Works

1. The mutation function is called with the user's input.
2. A **new entity instance** is created using the entity constructor.
3. The input is passed to `hydrate()` on the new entity.
4. The entity is **immediately added** to the `EntityManager` collection and tracked as a client-only entity.
5. The entity's `state` is set to `'pending'`.
6. The actual `mutationFn` runs asynchronously (e.g. server request).
7. On **success**: the entity's `state` becomes `'confirmed'`, and queries are invalidated based on the configured strategy.
8. On **error**: the entity's `state` becomes `'failed'`, and — with the default `'rollback'` strategy — the entity is **removed** from the collection entirely.

### Defining a CreateMutation

```ts title="folders.store.ts"
import { CreateMutation } from "mobx-query/mutations/CreateMutation";
import { Folder } from "./folder.entity";

interface CreateFolderInput {
  name: string;
  description: string;
}

export class FoldersStore {
  readonly createFolder = new CreateMutation<CreateFolderInput, typeof Folder>({
    entity: Folder,
    mutationFn: async (input, entity) => {
      // `entity` is the already-hydrated Folder instance
      await fetch("/api/folders", {
        method: "POST",
        body: JSON.stringify({ id: entity.id, ...input }),
        headers: { "Content-Type": "application/json" },
      });
    },
    invalidationStrategy: "all-entity-queries",
  });
}
```

The options object:

| Option                 | Type                                        | Description                                                                                                       |
| ---------------------- | ------------------------------------------- | ----------------------------------------------------------------------------------------------------------------- |
| `entity`               | Entity constructor                          | The entity class to create (e.g. `Folder`)                                                                        |
| `mutationFn`           | `(input, entity, context) => Promise<void>` | The server-side write function. Receives the raw input, the hydrated entity instance, and your registered context |
| `invalidationStrategy` | Strategy                                    | Which queries to invalidate on success (see [Invalidation Strategies](#invalidation-strategies))                  |
| `errorStrategy`        | `'rollback' \| 'keep'`                      | What to do with the entity on error (see [Error Strategies](#error-strategies))                                   |
| `onMutate`             | Callback                                    | Called before the mutation runs. Receives `(input, entity)`                                                       |
| `onSuccess`            | Callback                                    | Called on success. Receives `(input, entity, context)`                                                            |
| `onError`              | Callback                                    | Called on error. Receives `(error, input, context)`                                                               |
| `onSettled`            | Callback                                    | Called on both success and error. Receives `(input, error, entity, context)`                                      |

### Using in React

`CreateMutation` exposes a `useMutation()` hook that returns a trigger function:

```tsx
import { observer } from "mobx-react-lite";

const CreateFolderButton = observer(() => {
  const { rootStore } = useMQ();
  const createFolder = rootStore.folders.createFolder.useMutation();

  return (
    <button
      onClick={() => createFolder({ name: "New Folder", description: "" })}
    >
      Create Folder
    </button>
  );
});
```

The folder appears in the UI **immediately** after clicking — before the server responds.

## UpdateMutation

`UpdateMutation` handles modifications to an existing entity. It integrates deeply with the entity's [dirty tracking](/docs/guides/defining-entities#dirty-tracking) system.

### How It Works

1. The developer modifies observable properties directly on the entity (e.g. `folder.name = 'New Name'`).
2. The entity's `isDirty` flag becomes `true`.
3. When `mutate()` is called, it checks `isDirty` — if the entity hasn't changed, the mutation is **skipped**.
4. It also checks `state` — if an update is already `'pending'`, the new mutation is **skipped** to prevent duplicate requests.
5. The entity's `state` is set to `'pending'`.
6. The `mutationFn` runs, sending the current observable values to the server.
7. On **success**: `state` becomes `'confirmed'`, `isDirty` is cleared, and queries are invalidated.
8. On **error** with `'rollback'`: `state` becomes `'failed'`, and `entity.reset()` reverts all fields to their original server values.

### Defining an UpdateMutation

Update mutations are defined **on the entity itself**, because they operate on `this` — the entity's current observable state:

```ts title="folder.entity.ts"
import { UpdateMutation } from "mobx-query/mutations/UpdateMutation";

export class Folder extends Entity<string, FolderData> {
  @observable accessor name: string = "";
  @observable accessor description: string = "";
  @observable accessor isPinned: boolean = false;

  readonly updateMutation = new UpdateMutation({
    entity: Folder,
    instance: this,
    mutationFn: async () => {
      await fetch(`/api/folders/${this.id}`, {
        method: "PATCH",
        body: JSON.stringify({
          name: this.name,
          description: this.description,
          isPinned: this.isPinned,
        }),
        headers: { "Content-Type": "application/json" },
      });
    },
    invalidationStrategy: "all-entity-queries",
  });
}
```

| Option                 | Type                                | Description                                                   |
| ---------------------- | ----------------------------------- | ------------------------------------------------------------- |
| `entity`               | Entity constructor                  | The entity class (used for invalidation key grouping)         |
| `instance`             | Entity instance                     | The entity instance this mutation operates on — always `this` |
| `mutationFn`           | `(input, context) => Promise<void>` | The server-side write function. Reads values from `this`      |
| `invalidationStrategy` | Strategy                            | Which queries to invalidate on success                        |
| `errorStrategy`        | Strategy                            | What to do on error (`'rollback'` restores original values)   |

### Using in React

```tsx
const FolderEditor = observer(({ folder }: { folder: Folder }) => {
  const save = folder.updateMutation.useMutation();

  return (
    <div>
      <input
        value={folder.name}
        onChange={(e) => {
          folder.name = e.target.value;
        }}
      />
      <button onClick={save} disabled={!folder.isDirty}>
        Save
      </button>
    </div>
  );
});
```

### Calling Without React

Update mutations can also be called **outside of React** using the `mutate()` method directly. This is useful for actions defined on the entity:

```ts
@action onPinFolder() {
  this.isPinned = !this.isPinned;
  this.updateMutation.mutate();
}
```

<Callout type="info">
  The `useMutation()` hook registers the mutation with TanStack Query's React
  lifecycle and mutation cache — giving you devtools visibility and
  component-scoped cleanup. The `mutate()` method bypasses React but still runs
  through TanStack Query's mutation cache internally via `runSyncMutation`.
</Callout>

## DeleteMutation

`DeleteMutation` handles the removal of an entity. It provides **instant optimistic hiding** — the entity disappears from all query results immediately.

### How It Works

1. `mutate()` is called (takes no input — the entity to delete is already known).
2. The entity's `state` is set to `'pending'`.
3. The entity's ID is added to the `EntityManager.deletedRecordIds` set.
4. All queries that reference this entity **immediately filter it out** (because `getEntities()` checks `deletedRecordIds`).
5. The `mutationFn` runs asynchronously.
6. On **success**: the entity is **permanently removed** from the `EntityManager` collection, and queries are invalidated.
7. On **error**: the entity's ID is removed from `deletedRecordIds`, making it **reappear** in all queries.

### Defining a DeleteMutation

Like `UpdateMutation`, delete mutations are defined on the entity:

```ts title="folder.entity.ts"
import { DeleteMutation } from "mobx-query/mutations/DeleteMutation";

export class Folder extends Entity<string, FolderData> {
  readonly deleteMutation = new DeleteMutation({
    entity: Folder,
    instance: this,
    mutationFn: async () => {
      await fetch(`/api/folders/${this.id}`, { method: "DELETE" });
    },
    invalidationStrategy: "all-entity-queries",
  });
}
```

### Using in React and Outside

```tsx
// React hook
const FolderItem = observer(({ folder }: { folder: Folder }) => {
  const deleteFolder = folder.deleteMutation.useMutation();
  return <button onClick={deleteFolder}>Delete</button>;
});

// Direct call (e.g. from an action or event handler)
folder.deleteMutation.mutate();
```

<Callout type="warn">
  The `deletedRecordIds` mechanism means the entity is still in memory during
  the mutation. It's hidden from query results via the `getEntities()` filter,
  not removed from the collection. This enables clean rollback on error — the
  entity simply reappears.
</Callout>

## Invalidation Strategies

After a successful mutation, mobx-query needs to decide which queries to refetch so the UI stays consistent with the server. The `invalidationStrategy` option controls this behavior.

```ts
type OptimisticMutationInvalidationStrategy =
  | "all-queries"
  | "all-entity-queries"
  | "referenced-queries"
  | "none";
```

### `'all-queries'`

Invalidates **every query** across the entire application — regardless of entity type. This is the broadest possible strategy.

```ts
invalidationStrategy: "all-queries";
```

Under the hood, this calls:

```ts
queryClient.invalidateQueries();
```

**When to use**: For mutations that have cross-entity side effects (e.g. deleting a folder also affects document queries). Use sparingly — this triggers refetches for every active query.

### `'all-entity-queries'`

Invalidates **every query** that returns the **same entity type** as the mutation. This is the most common choice for creates and deletes.

```ts
// After creating a folder, all Folder queries are invalidated:
// - foldersPreviewQuery
// - folderByIdQuery
// - any other query using entity: Folder
invalidationStrategy: "all-entity-queries";
```

Under the hood, this calls:

```ts
queryClient.invalidateQueries({ queryKey: ["Folder"] });
```

Since all Folder queries have `'Folder'` as their first key segment, this matches every one of them.

**When to use**: For mutations that change the total set of entities (creates, deletes) or modify fields that could affect sort order or filtering in other queries.

### `'referenced-queries'` (default)

Invalidates only the queries that **directly reference the mutated entity** — determined by the entity's `queryHashes` set.

```ts
invalidationStrategy: "referenced-queries";
```

For example, if a `Folder` entity appears in `foldersPreviewQuery` and `folderByIdQuery`, only those two queries are refetched — not a `recentFoldersQuery` that doesn't include this particular folder.

**When to use**: When a mutation only affects the mutated entity itself (e.g. renaming a folder) and you want to minimize unnecessary refetches. This is the default strategy.

### `'none'`

Skips all invalidation. No queries are refetched after the mutation succeeds.

```ts
invalidationStrategy: "none";
```

**When to use**: For high-frequency mutations where you trust the optimistic state (e.g. auto-saving document content on every keystroke). You might manually invalidate later or rely on the user navigating away and back.

### Comparing Strategies

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                           Mutation succeeds                                  │
├───────────────────┬────────────────────┬────────────────────┬────────────────┤
│   'all-queries'   │'all-entity-queries'│'referenced-queries'│     'none'     │
├───────────────────┼────────────────────┼────────────────────┼────────────────┤
│ Invalidate ALL    │ Invalidate ALL     │ Invalidate ONLY    │ No invalidation│
│ queries in the    │ queries for this   │ queries that       │                │
│ entire app        │ entity type        │ reference this     │                │
│                   │                    │ specific entity    │                │
├───────────────────┼────────────────────┼────────────────────┼────────────────┤
│ Broadest, nuclear │ Broad, safe for    │ Targeted,          │ Manual control │
│                   │ entity collections │ efficient (default)│                │
└───────────────────┴────────────────────┴────────────────────┴────────────────┘
```

### Global Defaults

You can configure the default invalidation strategy for all mutations when initializing `MQClient`:

```ts
const client = new MQClient({
  context: { queryClient },
  entities: [Folder, Document],
  rootStore: () => new RootStore(),
  invalidationStrategy: "all-entity-queries", // default for all mutations
  errorStrategy: "rollback", // default for all mutations
});
```

Individual mutations can override the global default:

```ts
readonly updateMutation = new UpdateMutation({
  entity: Folder,
  instance: this,
  mutationFn: async () => { /* ... */ },
  invalidationStrategy: 'none', // overrides the global default
})
```

If no default is specified, `'referenced-queries'` is used.

## Error Strategies

When a mutation **fails**, you can configure what happens to the entity's local state:

```ts
type OptimisticMutationErrorStrategy = "rollback" | "keep";
```

### `'rollback'` (default)

Reverts the entity to its previous state:

- **`UpdateMutation`**: calls `entity.reset()`, restoring all `@observable accessor` fields to their server-confirmed values.
- **`CreateMutation`**: removes the entity from the `EntityManager` collection entirely.
- **`DeleteMutation`**: removes the entity's ID from `deletedRecordIds`, making it reappear in all query results.

```ts
readonly updateMutation = new UpdateMutation({
  entity: Folder,
  instance: this,
  mutationFn: async () => { /* ... */ },
  errorStrategy: 'rollback', // default — reverts on error
});
```

### `'keep'`

Preserves the optimistic state even after an error. The entity keeps its locally modified values and `state` is set to `'failed'`.

```ts
readonly updateMutation = new UpdateMutation({
  entity: Folder,
  instance: this,
  mutationFn: async () => { /* ... */ },
  errorStrategy: 'keep', // keep local changes, let the user retry
});
```

**When to use `'keep'`**: When you want to let the user correct the issue and retry without losing their input. For example, a form submission that fails due to a network error — having the values disappear is a worse UX than showing an error with a retry button.

### Combining Strategies

You can mix invalidation and error strategies for fine-grained control:

```ts
// Auto-save: no refetch, keep local values on error
readonly autoSaveMutation = new UpdateMutation({
  entity: Document,
  instance: this,
  mutationFn: async () => { /* ... */ },
  invalidationStrategy: 'none',
  errorStrategy: 'keep',
});

// Critical write: refetch everything, rollback on error
readonly publishMutation = new UpdateMutation({
  entity: Document,
  instance: this,
  mutationFn: async () => { /* ... */ },
  invalidationStrategy: 'all-entity-queries',
  errorStrategy: 'rollback',
});
```

## Entity State During Mutations

All entity mutations update the `entity.state` property through the `OptimisticMutationStrategy`:

```
confirmed ──── mutate() ────► pending
                                 │
                        ┌────────┴────────┐
                        ▼                  ▼
                    confirmed           failed
                  (on success)        (on error)
```

Use `entity.state` in your UI to show loading spinners, disable buttons, or display error indicators:

```tsx
const FolderActions = observer(({ folder }: { folder: Folder }) => {
  return (
    <div>
      <button
        onClick={() => folder.deleteMutation.mutate()}
        disabled={folder.state === "pending"}
      >
        {folder.state === "pending" ? "Deleting..." : "Delete"}
      </button>
      {folder.state === "failed" && (
        <span className="error">Operation failed. Please try again.</span>
      )}
    </div>
  );
});
```

## Lifecycle Callbacks

All mutation classes (`CreateMutation`, `UpdateMutation`, `DeleteMutation`) support lifecycle callbacks that run at specific points during the mutation:

| Callback    | When                          | Receives                             |
| ----------- | ----------------------------- | ------------------------------------ |
| `onMutate`  | Before `mutationFn` runs      | Entity + mutation context            |
| `onSuccess` | After `mutationFn` resolves   | Entity + context + `onMutate` result |
| `onError`   | After `mutationFn` rejects    | Error + entity + context             |
| `onSettled` | After either success or error | Entity + error (or null) + context   |

```ts
readonly createFolder = new CreateMutation<CreateFolderInput, typeof Folder>({
  entity: Folder,
  mutationFn: async (input, entity) => {
    await fetch('/api/folders', {
      method: 'POST',
      body: JSON.stringify({ id: entity.id, ...input }),
      headers: { 'Content-Type': 'application/json' },
    })
  },
  onMutate: (input, entity) => {
    console.log('Creating folder:', entity.id);
  },
  onSuccess: (input, entity) => {
    console.log('Folder created successfully:', entity.id);
    // Navigate to the new folder, show a toast, etc.
  },
  onError: (error) => {
    console.error('Failed to create folder:', error);
  },
});
```

<Callout type="idea">
  Lifecycle callbacks run **after** the built-in optimistic strategy logic. For
  example, `onError` runs after the entity has already been rolled back (if
  using `'rollback'` strategy). This means you can safely inspect `entity.state`
  and `entity.isDirty` in callbacks and they'll reflect the post-strategy state.
</Callout>
