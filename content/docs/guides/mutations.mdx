---
title: Mutations
description: Create, update, delete, and manage entity relations with built-in optimistic updates and configurable rollback strategies.
---

Mutations in mobx-query handle **write operations** — creating new entities, updating existing ones, deleting records, and managing many-to-many relations. Every mutation class integrates with TanStack Query's mutation cache and provides built-in optimistic update behavior with configurable strategies.

mobx-query provides five mutation classes:

| Class                    | Purpose                                       | Defined on      |
| ------------------------ | --------------------------------------------- | --------------- |
| `CreateMutation`         | Insert a new entity                           | Store           |
| `UpdateMutation`         | Modify an existing entity's fields            | Entity instance |
| `DeleteMutation`         | Remove an entity                              | Entity instance |
| `AddRelationMutation`    | Add an entity ID to a query's result set      | Entity instance |
| `RemoveRelationMutation` | Remove an entity ID from a query's result set | Entity instance |

## CreateMutation

`CreateMutation` handles the creation of new entities. It provides **instant optimistic insertion** — the entity appears in the UI immediately without waiting for the server response.

### How It Works

1. The mutation function is called with the user's input.
2. A **new entity instance** is created using the entity constructor.
3. The input is passed to `hydrate()` on the new entity.
4. The entity is **immediately added** to the `EntityManager` collection and tracked as a client-only entity.
5. The entity's `state` is set to `'pending'`.
6. The actual `mutationFn` runs asynchronously (e.g. server request).
7. On **success**: the entity's `state` becomes `'confirmed'`, and queries are invalidated based on the configured strategy.
8. On **error**: the entity's `state` becomes `'failed'`, and — with the default `'rollback'` strategy — the entity is **removed** from the collection entirely.

### Defining a CreateMutation

```ts title="folders.store.ts"
import { CreateMutation } from 'mobx-query/mutations/CreateMutation'
import { Folder } from './folder.entity'

interface CreateFolderInput {
  name: string
  description: string
}

export class FoldersStore {
  readonly createFolder = new CreateMutation<CreateFolderInput, typeof Folder>({
    entity: Folder,
    mutationFn: async (input, entity, ctx) => {
      // `entity` is the already-hydrated Folder instance
      await fetch('/api/folders', {
        method: 'POST',
        body: JSON.stringify({ id: entity.id, ...input }),
      })
    },
    invalidationStrategy: 'all-queries',
  })
}
```

The options object:

| Option                    | Type                                           | Description                                                                                                       |
| ------------------------- | ---------------------------------------------- | ----------------------------------------------------------------------------------------------------------------- |
| `entity`                  | Entity constructor                             | The entity class to create (e.g. `Folder`)                                                                        |
| `mutationFn`              | `(input, entity, context) => Promise<void>`    | The server-side write function. Receives the raw input, the hydrated entity instance, and your registered context |
| `invalidationStrategy`    | `'all-queries' \| 'related-queries' \| 'none'` | Which queries to invalidate on success (see [Invalidation Strategies](#invalidation-strategies))                  |
| `onMutationErrorStrategy` | `'rollback' \| 'keep'`                         | What to do with the entity on error (see [Error Strategies](#error-strategies))                                   |
| `onMutate`                | Callback                                       | Called before the mutation runs. Receives `(input, entity)`                                                       |
| `onSuccess`               | Callback                                       | Called on success. Receives `(input, entity, context)`                                                            |
| `onError`                 | Callback                                       | Called on error. Receives `(error, input, context)`                                                               |
| `onSettled`               | Callback                                       | Called on both success and error. Receives `(input, error, entity, context)`                                      |

### Using in React

`CreateMutation` exposes a `useMutation()` hook that returns a trigger function:

```tsx
import { observer } from 'mobx-react-lite'

const CreateFolderButton = observer(() => {
  const { rootStore } = useMQ()
  const createFolder = rootStore.folders.createFolder.useMutation()

  return (
    <button
      onClick={() => createFolder({ name: 'New Folder', description: '' })}
    >
      Create Folder
    </button>
  )
})
```

The folder appears in the UI **immediately** after clicking — before the server responds.

## UpdateMutation

`UpdateMutation` handles modifications to an existing entity. It integrates deeply with the entity's [dirty tracking](/docs/guides/defining-entities#dirty-tracking) system.

### How It Works

1. The developer modifies observable properties directly on the entity (e.g. `folder.name = 'New Name'`).
2. The entity's `isDirty` flag becomes `true`.
3. When `mutate()` is called, it checks `isDirty` — if the entity hasn't changed, the mutation is **skipped**.
4. It also checks `state` — if an update is already `'pending'`, the new mutation is **skipped** to prevent duplicate requests.
5. The entity's `state` is set to `'pending'`.
6. The `mutationFn` runs, sending the current observable values to the server.
7. On **success**: `state` becomes `'confirmed'`, `isDirty` is cleared, and queries are invalidated.
8. On **error** with `'rollback'`: `state` becomes `'failed'`, and `entity.reset()` reverts all fields to their original server values.

### Defining an UpdateMutation

Update mutations are defined **on the entity itself**, because they operate on `this` — the entity's current observable state:

```ts title="folder.entity.ts"
import { UpdateMutation } from 'mobx-query/mutations/UpdateMutation'

export class Folder extends Entity<string, FolderData> {
  @observable accessor name: string = ''
  @observable accessor description: string = ''
  @observable accessor isPinned: boolean = false

  readonly updateMutation = new UpdateMutation({
    entity: Folder,
    instance: this,
    mutationFn: async (_, { db }) => {
      await db
        .update(folder)
        .set({
          name: this.name,
          description: this.description,
          isPinned: this.isPinned,
        })
        .where(eq(folder.id, this.id))
    },
    invalidationStrategy: 'all-queries',
  })
}
```

| Option                    | Type                                | Description                                                   |
| ------------------------- | ----------------------------------- | ------------------------------------------------------------- |
| `entity`                  | Entity constructor                  | The entity class (used for invalidation key grouping)         |
| `instance`                | Entity instance                     | The entity instance this mutation operates on — always `this` |
| `mutationFn`              | `(input, context) => Promise<void>` | The server-side write function. Reads values from `this`      |
| `invalidationStrategy`    | Strategy                            | Which queries to invalidate on success                        |
| `onMutationErrorStrategy` | Strategy                            | What to do on error (`'rollback'` restores original values)   |

### Using in React

```tsx
const FolderEditor = observer(({ folder }: { folder: Folder }) => {
  const save = folder.updateMutation.useMutation()

  return (
    <div>
      <input
        value={folder.name}
        onChange={(e) => {
          folder.name = e.target.value
        }}
      />
      <button onClick={save} disabled={!folder.isDirty}>
        Save
      </button>
    </div>
  )
})
```

### Calling Without React

Update mutations can also be called **outside of React** using the `mutate()` method directly. This is useful for actions defined on the entity:

```ts
@action onPinFolder() {
  this.isPinned = !this.isPinned;
  this.updateMutation.mutate();
}
```

<Callout type="info">
  The `useMutation()` hook registers the mutation with TanStack Query's React
  lifecycle and mutation cache — giving you devtools visibility and
  component-scoped cleanup. The `mutate()` method bypasses React but still runs
  through TanStack Query's mutation cache internally via `runSyncMutation`.
</Callout>

## DeleteMutation

`DeleteMutation` handles the removal of an entity. It provides **instant optimistic hiding** — the entity disappears from all query results immediately.

### How It Works

1. `mutate()` is called (takes no input — the entity to delete is already known).
2. The entity's `state` is set to `'pending'`.
3. The entity's ID is added to the `EntityManager.deletedRecordIds` set.
4. All queries that reference this entity **immediately filter it out** (because `getEntities()` checks `deletedRecordIds`).
5. The `mutationFn` runs asynchronously.
6. On **success**: the entity is **permanently removed** from the `EntityManager` collection, and queries are invalidated.
7. On **error**: the entity's ID is removed from `deletedRecordIds`, making it **reappear** in all queries.

### Defining a DeleteMutation

Like `UpdateMutation`, delete mutations are defined on the entity:

```ts title="folder.entity.ts"
import { DeleteMutation } from 'mobx-query/mutations/DeleteMutation'

export class Folder extends Entity<string, FolderData> {
  readonly deleteMutation = new DeleteMutation({
    entity: Folder,
    instance: this,
    mutationFn: async (_, { db }) => {
      await db.delete(folder).where(eq(folder.id, this.id))
    },
    invalidationStrategy: 'all-queries',
  })
}
```

### Using in React and Outside

```tsx
// React hook
const FolderItem = observer(({ folder }: { folder: Folder }) => {
  const deleteFolder = folder.deleteMutation.useMutation()
  return <button onClick={deleteFolder}>Delete</button>
})

// Direct call (e.g. from an action or event handler)
folder.deleteMutation.mutate()
```

<Callout type="warn">
  The `deletedRecordIds` mechanism means the entity is still in memory during
  the mutation. It's hidden from query results via the `getEntities()` filter,
  not removed from the collection. This enables clean rollback on error — the
  entity simply reappears.
</Callout>

## Relation Mutations

`AddRelationMutation` and `RemoveRelationMutation` handle **many-to-many relationships** — scenarios where you're not creating or deleting entities, but adding or removing an entity from a specific query's result set.

### The Problem They Solve

Consider a `Document` that has many `Label` entities (via a join table). When you add a label to a document:

- The `Label` entity already exists in the `EntityManager`.
- You're not creating a new entity — you're adding a **relationship**.
- The `labelsQuery` on the document should optimistically show the newly associated label.

Relation mutations solve this by directly manipulating the **ID array** stored in a query's TanStack cache.

### AddRelationMutation

Optimistically appends an entity ID to a query's cached result set, then runs the actual mutation:

```ts title="document.entity.ts"
import { AddRelationMutation } from 'mobx-query/mutations/RelationMutation'

export class Document extends Entity<string, DocumentData> {
  readonly labelsQuery = new QueryFragmentMany({
    entity: Label,
    queryKey: () => ['documentLabels', this.id],
    queryFn: (_, { db }) => {
      /* ... */
    },
  })

  readonly addLabelMutation = new AddRelationMutation<string>({
    query: this.labelsQuery,
    mutationFn: async (labelId, { db }) => {
      await db.insert(documentLabel).values({
        documentId: this.id,
        labelId,
      })
    },
  })
}
```

**Flow:**

1. Snapshots the current ID array from the query cache.
2. Appends the new ID (if not already present).
3. Runs `mutationFn` asynchronously.
4. On **success**: invalidates the query.
5. On **error**: restores the original ID array (rollback).

**Usage:**

```ts
// Add label 'label-42' to this document
document.addLabelMutation.mutate('label-42')
```

### RemoveRelationMutation

The inverse — optimistically removes an entity ID from a query's cached result set:

```ts title="document.entity.ts"
import { RemoveRelationMutation } from 'mobx-query/mutations/RelationMutation'

export class Document extends Entity<string, DocumentData> {
  readonly removeLabelMutation = new RemoveRelationMutation<string>({
    query: this.labelsQuery,
    mutationFn: async (labelId, { db }) => {
      await db
        .delete(documentLabel)
        .where(
          and(
            eq(documentLabel.documentId, this.id),
            eq(documentLabel.labelId, labelId),
          ),
        )
    },
  })
}
```

**Flow:**

1. Snapshots the current ID array.
2. Filters out the target ID.
3. Runs `mutationFn` asynchronously.
4. On **success**: invalidates the query.
5. On **error**: restores the original ID array.

### Relation Mutation Options

| Option                 | Type                                | Description                                              |
| ---------------------- | ----------------------------------- | -------------------------------------------------------- |
| `query`                | `QueryManyBase` instance            | The query whose cached ID array to manipulate            |
| `mutationFn`           | `(input, context) => Promise<void>` | The server-side write function                           |
| `queryArgs`            | `unknown` (optional)                | Arguments for query key resolution. Default: `undefined` |
| `invalidationStrategy` | Strategy (optional)                 | Defaults to `'related-queries'`                          |

<Callout type="info">
  Relation mutations only operate on the **ID array** in the query cache. They
  don't create or delete entity instances. The entity being added must already
  exist in the `EntityManager` (e.g. it was fetched by another query).
</Callout>

## Invalidation Strategies

After a successful mutation, mobx-query needs to decide which queries to refetch so the UI stays consistent with the server. The `invalidationStrategy` option controls this behavior.

```ts
type OptimisticMutationInvalidationStrategy =
  | 'all-queries'
  | 'related-queries'
  | 'none'
```

### `'all-queries'`

Invalidates **every query** that returns the same entity type. This is the broadest and safest strategy.

```ts
// After creating a folder, all Folder queries are invalidated:
// - foldersPreviewQuery
// - folderByIdQuery
// - any other query using entity: Folder
invalidationStrategy: 'all-queries'
```

Under the hood, this calls:

```ts
queryClient.invalidateQueries({ queryKey: ['Folder'] })
```

Since all Folder queries have `'Folder'` as their first key segment, this matches every one of them.

**When to use**: For mutations that change the total set of entities (creates, deletes) or modify fields that could affect sort order or filtering in other queries. This is the most common choice.

### `'related-queries'`

Invalidates only the queries that **directly reference the mutated entity** — determined by the entity's `queryHashes` set.

```ts
invalidationStrategy: 'related-queries'
```

For example, if a `Folder` entity appears in `foldersPreviewQuery` and `folderByIdQuery`, only those two queries are refetched — not a `recentFoldersQuery` that doesn't include this particular folder.

**When to use**: When a mutation only affects the mutated entity itself (e.g. renaming a folder) and you want to minimize unnecessary refetches.

### `'none'`

Skips all invalidation. No queries are refetched after the mutation succeeds.

```ts
invalidationStrategy: 'none'
```

**When to use**: For high-frequency mutations where you trust the optimistic state (e.g. auto-saving document content on every keystroke). You might manually invalidate later or rely on the user navigating away and back.

### Comparing Strategies

```
┌───────────────────────────────────────────────────────┐
│                    Mutation succeeds                   │
├──────────────────┬──────────────────┬────────────────┤
│   'all-queries'  │ 'related-queries'│     'none'     │
├──────────────────┼──────────────────┼────────────────┤
│ Invalidate ALL   │ Invalidate ONLY  │ No invalidation│
│ queries for this │ queries that     │                │
│ entity type      │ reference this   │                │
│                  │ specific entity  │                │
├──────────────────┼──────────────────┼────────────────┤
│ Broadest, safest │ Targeted,        │ Manual control │
│                  │ efficient        │                │
└──────────────────┴──────────────────┴────────────────┘
```

## Error Strategies

When a mutation **fails**, you can configure what happens to the entity's local state:

```ts
type OptimisticMutationErrorStrategy = 'rollback' | 'keep'
```

### `'rollback'` (default)

Reverts the entity to its previous state:

- **`UpdateMutation`**: calls `entity.reset()`, restoring all `@observable accessor` fields to their server-confirmed values.
- **`CreateMutation`**: removes the entity from the `EntityManager` collection entirely.
- **`DeleteMutation`**: removes the entity's ID from `deletedRecordIds`, making it reappear in all query results.
- **Relation mutations**: restore the previous ID array from the snapshot.

```ts
readonly updateMutation = new UpdateMutation({
  entity: Folder,
  instance: this,
  mutationFn: async (_, ctx) => { /* ... */ },
  onMutationErrorStrategy: 'rollback', // default — reverts on error
});
```

### `'keep'`

Preserves the optimistic state even after an error. The entity keeps its locally modified values and `state` is set to `'failed'`.

```ts
readonly updateMutation = new UpdateMutation({
  entity: Folder,
  instance: this,
  mutationFn: async (_, ctx) => { /* ... */ },
  onMutationErrorStrategy: 'keep', // keep local changes, let the user retry
});
```

**When to use `'keep'`**: When you want to let the user correct the issue and retry without losing their input. For example, a form submission that fails due to a network error — having the values disappear is a worse UX than showing an error with a retry button.

### Combining Strategies

You can mix invalidation and error strategies for fine-grained control:

```ts
// Auto-save: no refetch, keep local values on error
readonly autoSaveMutation = new UpdateMutation({
  entity: Document,
  instance: this,
  mutationFn: async (_, ctx) => { /* ... */ },
  invalidationStrategy: 'none',
  onMutationErrorStrategy: 'keep',
});

// Critical write: refetch everything, rollback on error
readonly publishMutation = new UpdateMutation({
  entity: Document,
  instance: this,
  mutationFn: async (_, ctx) => { /* ... */ },
  invalidationStrategy: 'all-queries',
  onMutationErrorStrategy: 'rollback',
});
```

## Entity State During Mutations

All entity mutations update the `entity.state` property through the `OptimisticMutationStrategy`:

```
confirmed ──── mutate() ────► pending
                                 │
                        ┌────────┴────────┐
                        ▼                  ▼
                    confirmed           failed
                  (on success)        (on error)
```

Use `entity.state` in your UI to show loading spinners, disable buttons, or display error indicators:

```tsx
const FolderActions = observer(({ folder }: { folder: Folder }) => {
  return (
    <div>
      <button
        onClick={() => folder.deleteMutation.mutate()}
        disabled={folder.state === 'pending'}
      >
        {folder.state === 'pending' ? 'Deleting...' : 'Delete'}
      </button>
      {folder.state === 'failed' && (
        <span className="error">Operation failed. Please try again.</span>
      )}
    </div>
  )
})
```

## Lifecycle Callbacks

All mutation classes (`CreateMutation`, `UpdateMutation`, `DeleteMutation`) support lifecycle callbacks that run at specific points during the mutation:

| Callback    | When                          | Receives                             |
| ----------- | ----------------------------- | ------------------------------------ |
| `onMutate`  | Before `mutationFn` runs      | Entity + mutation context            |
| `onSuccess` | After `mutationFn` resolves   | Entity + context + `onMutate` result |
| `onError`   | After `mutationFn` rejects    | Error + entity + context             |
| `onSettled` | After either success or error | Entity + error (or null) + context   |

```ts
readonly createFolder = new CreateMutation<CreateFolderInput, typeof Folder>({
  entity: Folder,
  mutationFn: async (input, entity, ctx) => { /* ... */ },
  onMutate: (input, entity) => {
    console.log('Creating folder:', entity.id);
  },
  onSuccess: (input, entity) => {
    console.log('Folder created successfully:', entity.id);
    // Navigate to the new folder, show a toast, etc.
  },
  onError: (error) => {
    console.error('Failed to create folder:', error);
  },
});
```

<Callout type="idea">
  Lifecycle callbacks run **after** the built-in optimistic strategy logic. For
  example, `onError` runs after the entity has already been rolled back (if
  using `'rollback'` strategy). This means you can safely inspect `entity.state`
  and `entity.isDirty` in callbacks and they'll reflect the post-strategy state.
</Callout>

## Summary

| Mutation                 | Optimistic behavior                     | Rollback on error                           | Defined on |
| ------------------------ | --------------------------------------- | ------------------------------------------- | ---------- |
| `CreateMutation`         | Entity instantly added to collection    | Entity removed from collection              | Store      |
| `UpdateMutation`         | Entity fields already modified via MobX | `entity.reset()` reverts to original values | Entity     |
| `DeleteMutation`         | Entity hidden from all query results    | Entity reappears in query results           | Entity     |
| `AddRelationMutation`    | Entity ID appended to query's ID array  | ID array restored from snapshot             | Entity     |
| `RemoveRelationMutation` | Entity ID removed from query's ID array | ID array restored from snapshot             | Entity     |
